<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tag Category Selector</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#4f46e5">
  <style>
    :root{--bg:#f5f5f5;--card:#fff;--text:#111;--muted:#666;--accent:#4f46e5;--danger:#dc2626;--ok:#16a34a}
    body.dark{--bg:#0f172a;--card:#020617;--text:#e5e7eb;--muted:#94a3b8;--accent:#6366f1}
    body{font-family:system-ui,sans-serif;margin:0;padding:12px;background:var(--bg);color:var(--text)}
    h1{font-size:1.2rem;margin:0 0 8px}

    .controls{display:flex;gap:6px;flex-wrap:wrap;margin-bottom:10px;align-items:center}
    input,button,textarea,select{font-size:.85rem;padding:6px 8px;border-radius:8px;border:1px solid #ccc}
    body.dark input, body.dark textarea, body.dark select{background:#020617;color:#e5e7eb;border-color:#334155}

    button{background:var(--accent);color:#fff;border:none;cursor:pointer}
    button.secondary{background:#64748b}
    button.danger{background:var(--danger)}
    button.ok{background:var(--ok)}
    button.ghost{background:transparent;color:var(--text);border:1px solid rgba(0,0,0,.15)}
    body.dark button.ghost{border-color:#334155}

    textarea{width:100%;min-height:52px}

    .panel{background:var(--card);border-radius:12px;padding:10px;margin-bottom:12px;box-shadow:0 2px 6px rgba(0,0,0,.12)}
    .panel.hidden{display:none}
    .panel-title{display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap}
    .small{font-size:.75rem;color:var(--muted);line-height:1.35}
    .chip{display:inline-block;padding:2px 6px;border-radius:999px;background:rgba(79,70,229,.12);font-size:.72rem;margin:2px 4px 0 0}
    body.dark .chip{background:rgba(99,102,241,.18)}

    .banner{position:sticky;top:8px;z-index:10;background:var(--card);border-radius:12px;padding:10px;margin-bottom:12px;box-shadow:0 6px 18px rgba(0,0,0,.18);border:1px solid rgba(0,0,0,.08)}
    body.dark .banner{border-color:#1f2937}

    .toast{position:fixed;left:12px;right:12px;bottom:12px;z-index:999;background:var(--card);border-radius:12px;padding:10px;box-shadow:0 10px 30px rgba(0,0,0,.25);border:1px solid rgba(0,0,0,.08)}
    body.dark .toast{border-color:#1f2937}
    .toast.hidden{display:none}

    /* Groups */
    .group{background:var(--card);border-radius:14px;padding:10px;margin-bottom:14px;box-shadow:0 2px 6px rgba(0,0,0,.12)}
    .group.collapsed .group-body{display:none}
    .group-head{display:flex;align-items:center;justify-content:space-between;gap:8px;flex-wrap:wrap;margin-bottom:6px}
    .group-left{display:flex;align-items:center;gap:8px;min-width:180px}
    .toggle{cursor:pointer;user-select:none;font-size:.9rem;opacity:.85}

    /* Categories */
    .category{background:var(--card);border-radius:12px;padding:10px;margin:10px 0 0;box-shadow:0 2px 6px rgba(0,0,0,.10)}
    .category.collapsed .tags,.category.collapsed .add-wrap,.category.collapsed .cat-output,.category.collapsed .cat-actions-row{display:none}
    .category-header{display:flex;justify-content:space-between;align-items:center;gap:6px;flex-wrap:wrap;margin-bottom:6px}
    .cat-left{display:flex;align-items:center;gap:8px;min-width:180px}
    .stat{font-size:.75rem;color:var(--muted)}
    .pin{font-size:.75rem;cursor:pointer;user-select:none}

    .tags{display:flex;flex-wrap:wrap;gap:6px}
    .tag{padding:6px 10px;border-radius:20px;background:#c7c7c7;color:#000;cursor:pointer;font-size:.85rem;user-select:none}
    body.dark .tag{background:#334155;color:#e5e7eb}
    .tag.selected{background:var(--accent);color:#fff}
    .tag.mark{background:var(--danger);color:#fff}

    .locked{opacity:.6;pointer-events:none}

    .row{display:flex;gap:6px;flex-wrap:wrap;align-items:center}
    .spacer{flex:1}

    .section-title{display:flex;align-items:baseline;justify-content:space-between;gap:10px;flex-wrap:wrap;margin:12px 0 6px}
  </style>
</head>
<body>
<h1>Tag Category Selector</h1>

<!-- Global controls -->
<div class="controls">
  <input id="newCategoryName" placeholder="New category">
  <input type="color" id="newCategoryColor" title="Category color">
  <button onclick="addCategory()">Add Category</button>
  <button class="secondary" onclick="toggleDark()">Dark</button>
  <button class="secondary" onclick="toggleRegexHelp()">Regex Help</button>
  <button onclick="toggleAIPanel()">AI Grouping</button>
</div>

<div class="controls">
  <span class="small" style="margin-right:6px">Import:</span>
  <label class="small" style="display:flex;align-items:center;gap:6px;border:1px dashed rgba(0,0,0,.25);padding:6px 8px;border-radius:10px">
    <b>.txt</b>
    <input type="file" accept=".txt" onchange="loadTxt(event)" style="max-width:200px">
  </label>
  <label class="small" style="display:flex;align-items:center;gap:6px;border:1px dashed rgba(0,0,0,.25);padding:6px 8px;border-radius:10px">
    <b>.json</b>
    <input type="file" accept=".json" onchange="importJSON(event)" style="max-width:200px">
  </label>
  <button class="secondary" onclick="exportJSON()">Export JSON (All)</button>
  <button class="secondary" onclick="exportAllTXT()">Export TXT (All)</button>
</div>

<div class="controls">
  <input id="search" placeholder="Search" oninput="render()">
  <input id="regex" placeholder="Regex" oninput="render()">
  <button class="ghost" onclick="collapseAll()">Collapse All</button>
  <button class="ghost" onclick="expandAll()">Expand All</button>
  <button class="secondary" onclick="deselectAll()">Deselect All</button>
  <button class="danger" onclick="toggleDeleteMode()" id="multiDeleteBtn">Multi-Delete</button>
</div>

<!-- Multi-delete banner -->
<div id="deleteBanner" class="banner hidden">
  <div class="row">
    <strong>Multi-delete mode is ON</strong>
    <span class="small">Tap tags to mark them red. Then delete or cancel.</span>
    <span class="spacer"></span>
    <span class="small" id="markedCount">0 marked</span>
  </div>
  <div class="row" style="margin-top:8px">
    <button class="danger" onclick="commitMultiDelete()">Delete Marked</button>
    <button class="secondary" onclick="cancelMultiDelete()">Cancel</button>
  </div>
</div>

<!-- Regex help -->
<div id="regexHelp" class="panel hidden">
  <div class="panel-title">
    <strong>Regex Cheat Sheet</strong>
    <button class="secondary" onclick="toggleRegexHelp()">Close</button>
  </div>
  <div class="small" style="margin-top:8px">Regex filters by pattern. Leave blank if you don‚Äôt need it.</div>
  <div style="margin-top:8px">
    <span class="chip">^cat</span> starts with ‚Äúcat‚Äù
    <br><span class="chip">ing$</span> ends with ‚Äúing‚Äù
    <br><span class="chip">cat|dog</span> cat <em>or</em> dog
    <br><span class="chip">^[0-9]</span> starts with a number
    <br><span class="chip">^[a-zA-Z]+$</span> only letters
    <br><span class="chip">^.{5}$</span> exactly 5 characters
  </div>
  <div class="small" style="margin-top:8px">Search + Regex both apply (tags must pass both).</div>
</div>

<!-- AI grouping (hybrid + offline demo) -->
<div id="aiPanel" class="panel hidden">
  <div class="panel-title">
    <strong>AI Tag Grouping</strong>
    <button class="secondary" onclick="toggleAIPanel()">Close</button>
  </div>
  <div class="small" style="margin-top:8px">
    <b>Hybrid mode:</b> Offline grouping runs on-device. Online AI only runs if you enable it.
  </div>
  <div class="row" style="margin-top:8px">
    <label class="small" style="display:flex;align-items:center;gap:6px">
      <input type="checkbox" id="aiEnabledToggle" onchange="setAIEnabled(this.checked)">
      Enable Online AI (privacy toggle)
    </label>
    <span class="spacer"></span>
    <label class="small" style="display:flex;align-items:center;gap:6px">
      <input type="checkbox" id="autoCollapseToggle" onchange="setAutoCollapse(this.checked)">
      Auto-collapse category after selecting a tag
    </label>
  </div>
  <div class="row" style="margin-top:8px">
    <button onclick="runOfflineGrouping()">Run Offline Grouping</button>
    <button class="secondary" onclick="runOnlineGrouping()">Refine with AI (Online)</button>
  </div>
  <div id="aiResults" style="margin-top:8px"></div>
  <div class="small" style="margin-top:8px">
    Offline demo groups tags by shared ‚Äúroot‚Äù (split on <code>_</code> and <code>-</code>). Online AI can use embeddings + clustering.
  </div>
</div>

<!-- Groups + categories container -->
<div id="content"></div>

<h3>All Selected Tags</h3>
<textarea id="globalOutput" readonly></textarea>

<!-- Toast / Undo -->
<div id="toast" class="toast hidden">
  <div class="row">
    <div>
      <strong id="toastMsg">Done.</strong>
      <div class="small" id="toastSub"></div>
    </div>
    <span class="spacer"></span>
    <button class="secondary" onclick="undo()">Undo</button>
    <button class="ghost" onclick="hideToast()">Close</button>
  </div>
</div>

<script>
if('serviceWorker' in navigator){navigator.serviceWorker.register('sw.js')}

// ---------- State (v2) ----------
const STORAGE_KEY='tagAppStateV2';

let state=loadState();
let selected=new Set(state.ui.selected || []); // global selected tags (string)
let deleteMode=false;
let deleteMarks=new Map(); // catId -> Set(tag)

function uid(){return 'id_'+Math.random().toString(16).slice(2)+Date.now().toString(16)}

function loadState(){
  // Prefer unified state
  const raw=localStorage.getItem(STORAGE_KEY);
  if(raw){
    try{const s=JSON.parse(raw);return normalizeState(s)}catch{}
  }
  // Migrate from legacy keys (your last functional version)
  const legacyData=JSON.parse(localStorage.getItem('tagData')||'{}');
  const legacyColors=JSON.parse(localStorage.getItem('tagColors')||'{}');
  const legacyLocks=JSON.parse(localStorage.getItem('tagLocks')||'{}');
  const legacyPins=JSON.parse(localStorage.getItem('tagPins')||'{}');
  const legacyUsage=JSON.parse(localStorage.getItem('tagUsage')||'{}');
  const legacyDark=localStorage.getItem('darkMode')==='1';
  const legacyCollapsed=JSON.parse(localStorage.getItem('collapsedCats')||'{}');
  const legacyAI=localStorage.getItem('aiEnabled')==='1';

  const categories={};
  Object.keys(legacyData).forEach(name=>{
    const id=uid();
    categories[id]={
      id,
      name,
      color: legacyColors[name] || '#4f46e5',
      tags: Array.isArray(legacyData[name]) ? legacyData[name] : [],
      locked: !!legacyLocks[name],
      pinned: !!legacyPins[name],
      collapsed: !!legacyCollapsed[name],
      createdAt: Date.now(),
    };
  });

  const usage=[];
  // legacyUsage is an object keyed by random numbers
  Object.values(legacyUsage||{}).forEach(u=>{ if(u && u.tag && u.cat && u.time) usage.push({tag:u.tag, catName:u.cat, time:u.time}); });

  const s={
    version:2,
    categories,
    groups:{},
    usage,
    ui:{
      dark: legacyDark,
      aiEnabled: legacyAI,
      autoCollapseOnSelect:false,
      selected: [],
      undoStack: [],
    }
  };
  return normalizeState(s);
}

function normalizeState(s){
  if(!s || typeof s!=='object') s={};
  if(!s.version) s.version=2;
  if(!s.categories) s.categories={};
  if(!s.groups) s.groups={};
  if(!Array.isArray(s.usage)) s.usage=[];
  if(!s.ui) s.ui={};
  if(!Array.isArray(s.ui.selected)) s.ui.selected=[];
  if(!Array.isArray(s.ui.undoStack)) s.ui.undoStack=[];
  if(typeof s.ui.dark!=='boolean') s.ui.dark=false;
  if(typeof s.ui.aiEnabled!=='boolean') s.ui.aiEnabled=false;
  if(typeof s.ui.autoCollapseOnSelect!=='boolean') s.ui.autoCollapseOnSelect=false;
  return s;
}

function saveState(){
  state.ui.selected=[...selected];
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  // Keep legacy darkMode for backwards compatibility with your old file
  localStorage.setItem('darkMode', state.ui.dark?'1':'0');
}

// ---------- Undo ----------
function pushUndo(action){
  state.ui.undoStack.push(action);
  // limit
  if(state.ui.undoStack.length>50) state.ui.undoStack.shift();
  saveState();
}

function undo(){
  const a=state.ui.undoStack.pop();
  if(!a){hideToast();return;}

  if(a.type==='deleteCategory'){
    state.categories[a.cat.id]=a.cat;
    if(a.groupId){
      const g=state.groups[a.groupId];
      if(g && !g.categoryIds.includes(a.cat.id)) g.categoryIds.push(a.cat.id);
    }
  }

  if(a.type==='deleteGroup'){
    state.groups[a.group.id]=a.group;
  }

  if(a.type==='multiDelete'){
    // Restore removed tags into categories at their original indices
    for(const rec of a.removed){
      const cat=state.categories[rec.catId];
      if(!cat) continue;
      // insert in ascending index order
      rec.items.sort((x,y)=>x.index-y.index).forEach(it=>{
        const idx=Math.max(0, Math.min(it.index, cat.tags.length));
        cat.tags.splice(idx, 0, it.tag);
      });
    }
  }

  if(a.type==='renameCategory'){
    const cat=state.categories[a.catId];
    if(cat) cat.name=a.oldName;
  }

  if(a.type==='recolorCategory'){
    const cat=state.categories[a.catId];
    if(cat) cat.color=a.oldColor;
  }

  if(a.type==='deleteCategoriesFromGroup'){
    // restore categories and restore group membership
    for(const cat of a.cats){ state.categories[cat.id]=cat; }
    const g=state.groups[a.groupId];
    if(g){
      a.cats.forEach(cat=>{ if(!g.categoryIds.includes(cat.id)) g.categoryIds.push(cat.id); });
    }
  }

  saveState();
  render();
  showToast('Undone.', '');
}

function showToast(msg, sub){
  toastMsg.textContent=msg;
  toastSub.textContent=sub||'';
  toast.classList.remove('hidden');
}
function hideToast(){toast.classList.add('hidden');}

// ---------- Theme ----------
function applyTheme(){
  if(state.ui.dark) document.body.classList.add('dark');
  else document.body.classList.remove('dark');
}
function toggleDark(){state.ui.dark=!state.ui.dark;saveState();applyTheme();}

// ---------- Top-level actions ----------
function deselectAll(){
  selected.clear();
  saveState();
  render();
}

function collapseAll(){
  Object.values(state.categories).forEach(c=>c.collapsed=true);
  Object.values(state.groups).forEach(g=>g.collapsed=true);
  saveState();
  render();
}

function expandAll(){
  Object.values(state.categories).forEach(c=>c.collapsed=false);
  Object.values(state.groups).forEach(g=>g.collapsed=false);
  saveState();
  render();
}

// ---------- Category CRUD ----------
function addCategory(){
  const name=newCategoryName.value.trim();
  if(!name) return;
  // prevent duplicate names (best effort)
  if(Object.values(state.categories).some(c=>c.name.toLowerCase()===name.toLowerCase())){
    alert('A category with that name already exists.');
    return;
  }
  const id=uid();
  state.categories[id]={id,name,color:newCategoryColor.value||'#4f46e5',tags:[],locked:false,pinned:false,collapsed:false,createdAt:Date.now()};
  newCategoryName.value='';
  saveState();
  render();
}

function confirmDeleteCategory(catId){
  const cat=state.categories[catId];
  if(!cat) return;
  const msg=`Delete category "${cat.name}"? This will remove the category and its tags.`;
  if(!confirm(msg)) return;

  // remember which group it was in (if any)
  const groupId=findGroupOfCategory(catId);
  if(groupId){
    const g=state.groups[groupId];
    g.categoryIds=g.categoryIds.filter(id=>id!==catId);
  }

  delete state.categories[catId];
  pushUndo({type:'deleteCategory', cat, groupId});
  saveState();
  render();
  showToast('Category deleted.', 'Tap Undo to restore it.');
}

function renameCategory(catId){
  const cat=state.categories[catId];
  if(!cat) return;
  const next=prompt('Rename category:', cat.name);
  if(!next) return;
  const trimmed=next.trim();
  if(!trimmed || trimmed===cat.name) return;
  if(Object.values(state.categories).some(c=>c.id!==catId && c.name.toLowerCase()===trimmed.toLowerCase())){
    alert('A category with that name already exists.');
    return;
  }
  pushUndo({type:'renameCategory', catId, oldName:cat.name});
  cat.name=trimmed;
  saveState();
  render();
}

function recolorCategory(catId){
  const cat=state.categories[catId];
  if(!cat) return;
  const old=cat.color;
  const next=prompt('Set color (hex like #4f46e5):', old);
  if(!next) return;
  const v=next.trim();
  if(!/^#([0-9a-fA-F]{6})$/.test(v)){
    alert('Please enter a valid 6-digit hex color like #4f46e5');
    return;
  }
  pushUndo({type:'recolorCategory', catId, oldColor:old});
  cat.color=v;
  saveState();
  render();
}

function toggleCatCollapse(catId){
  const cat=state.categories[catId];
  if(!cat) return;
  cat.collapsed=!cat.collapsed;
  saveState();
  render();
}

function togglePin(catId){
  const cat=state.categories[catId];
  if(!cat) return;
  cat.pinned=!cat.pinned;
  saveState();
  render();
}

function toggleLock(catId){
  const cat=state.categories[catId];
  if(!cat) return;
  cat.locked=!cat.locked;
  saveState();
  render();
}

function addTag(catId, tag){
  const cat=state.categories[catId];
  if(!cat || cat.locked) return;
  const t=tag.trim();
  if(!t) return;
  cat.tags.push(t);
  saveState();
  render();
}

function suggest(input, catId){
  const v=input.value.toLowerCase();
  if(!v) return;
  const cat=state.categories[catId];
  if(!cat) return;
  const all=[...new Set(Object.values(state.categories).flatMap(c=>c.tags))];
  const match=all.find(t=>t.toLowerCase().startsWith(v) && !cat.tags.includes(t));
  if(match) input.value=match;
}

function deselectCategory(catId){
  const cat=state.categories[catId];
  if(!cat) return;
  cat.tags.forEach(t=>selected.delete(t));
  saveState();
  render();
}

// ---------- Grouping ----------
function createGroup(){
  const name=prompt('Group name:','');
  if(!name) return;
  const trimmed=name.trim();
  if(!trimmed) return;
  const id=uid();
  state.groups[id]={id,name:trimmed,color:'#4f46e5',collapsed:false,categoryIds:[],createdAt:Date.now()};
  saveState();
  render();
}

function renameGroup(groupId){
  const g=state.groups[groupId];
  if(!g) return;
  const next=prompt('Rename group:', g.name);
  if(!next) return;
  g.name=next.trim()||g.name;
  saveState();
  render();
}

function recolorGroup(groupId){
  const g=state.groups[groupId];
  if(!g) return;
  const next=prompt('Set group color (hex):', g.color);
  if(!next) return;
  const v=next.trim();
  if(!/^#([0-9a-fA-F]{6})$/.test(v)){
    alert('Please enter a valid 6-digit hex color like #4f46e5');
    return;
  }
  g.color=v;
  saveState();
  render();
}

function toggleGroupCollapse(groupId){
  const g=state.groups[groupId];
  if(!g) return;
  g.collapsed=!g.collapsed;
  saveState();
  render();
}

function deleteGroup(groupId){
  const g=state.groups[groupId];
  if(!g) return;
  if(!confirm(`Delete group "${g.name}"?`)) return;
  const choice=prompt('Type 1 to delete ONLY the group, or type 2 to delete the group + ALL its categories.','1');
  if(choice!=='1' && choice!=='2') return;

  if(choice==='1'){
    // ungroup categories
    const groupCopy=JSON.parse(JSON.stringify(g));
    delete state.groups[groupId];
    pushUndo({type:'deleteGroup', group:groupCopy});
    saveState();
    render();
    showToast('Group deleted.', 'Categories were kept. Undo to restore.');
    return;
  }

  // choice === 2
  if(!confirm('This will permanently delete ALL categories in the group. Are you sure?')) return;

  const cats=g.categoryIds.map(id=>state.categories[id]).filter(Boolean);
  const groupCopy=JSON.parse(JSON.stringify(g));
  // remove categories
  cats.forEach(c=>delete state.categories[c.id]);
  delete state.groups[groupId];

  pushUndo({type:'deleteCategoriesFromGroup', groupId, cats});
  pushUndo({type:'deleteGroup', group:groupCopy});

  saveState();
  render();
  showToast('Group + categories deleted.', 'Undo to restore.');
}

function findGroupOfCategory(catId){
  for(const g of Object.values(state.groups)){
    if((g.categoryIds||[]).includes(catId)) return g.id;
  }
  return null;
}

function openGroupManager(groupId){
  const g=state.groups[groupId];
  if(!g) return;

  // simple selector via prompt: comma-separated category names to add/remove
  const allCats=Object.values(state.categories).map(c=>c.name).sort();
  const current=g.categoryIds.map(id=>state.categories[id]?.name).filter(Boolean);
  const msg=`Edit categories in group "${g.name}".\n\nCurrent: ${current.join(', ')||'(none)'}\n\nAvailable: ${allCats.join(', ')}\n\nEnter category names (comma-separated) to be in the group:`;
  const input=prompt(msg, current.join(', '));
  if(input===null) return;

  const wanted=input.split(',').map(s=>s.trim()).filter(Boolean);
  const wantedIds=[];
  for(const name of wanted){
    const cat=Object.values(state.categories).find(c=>c.name.toLowerCase()===name.toLowerCase());
    if(cat) wantedIds.push(cat.id);
  }

  g.categoryIds=[...new Set(wantedIds)];
  saveState();
  render();
}

function selectAllInGroup(groupId){
  const g=state.groups[groupId];
  if(!g) return;
  g.categoryIds.forEach(id=>{
    const cat=state.categories[id];
    if(cat) cat.tags.forEach(t=>selected.add(t));
  });
  saveState();
  render();
}

function deselectAllInGroup(groupId){
  const g=state.groups[groupId];
  if(!g) return;
  g.categoryIds.forEach(id=>{
    const cat=state.categories[id];
    if(cat) cat.tags.forEach(t=>selected.delete(t));
  });
  saveState();
  render();
}

// ---------- Multi-delete ----------
function toggleDeleteMode(){
  deleteMode=!deleteMode;
  deleteMarks.clear();
  updateDeleteUI();
  render();
}

function updateDeleteUI(){
  const btn=document.getElementById('multiDeleteBtn');
  btn.textContent=deleteMode?'Multi-Delete (ON)':'Multi-Delete';
  const banner=document.getElementById('deleteBanner');
  banner.classList.toggle('hidden', !deleteMode);
  if(deleteMode) showToast('Multi-delete is ON.', 'Mark tags, then Delete Marked or Cancel.');
  else hideToast();
  updateMarkedCount();
}

function updateMarkedCount(){
  let n=0;
  for(const set of deleteMarks.values()) n+=set.size;
  markedCount.textContent=`${n} marked`;
}

function commitMultiDelete(){
  // Remove marked tags, store indices for undo
  const removed=[];
  for(const [catId,set] of deleteMarks.entries()){
    const cat=state.categories[catId];
    if(!cat || cat.locked) continue;
    const items=[];
    // capture indices before removal
    cat.tags.forEach((t,i)=>{ if(set.has(t)) items.push({tag:t,index:i}); });
    if(items.length){
      cat.tags=cat.tags.filter(t=>!set.has(t));
      items.forEach(it=>selected.delete(it.tag));
      removed.push({catId,items});
    }
  }

  if(removed.length){
    pushUndo({type:'multiDelete', removed});
    showToast('Tags deleted.', 'Undo to restore deleted tags.');
  }

  deleteMode=false;
  deleteMarks.clear();
  updateDeleteUI();
  saveState();
  render();
}

function cancelMultiDelete(){
  deleteMode=false;
  deleteMarks.clear();
  updateDeleteUI();
  render();
}

// ---------- Import / Export ----------
function loadTxt(e){
  const f=e.target.files[0];
  if(!f) return;
  const r=new FileReader();
  r.onload=()=>{
    const lines=r.result.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
    const catName=prompt('Which category should these tags go into?');
    if(!catName) return;
    let cat=Object.values(state.categories).find(c=>c.name.toLowerCase()===catName.trim().toLowerCase());
    if(!cat){
      const id=uid();
      cat={id,name:catName.trim(),color:newCategoryColor.value||'#4f46e5',tags:[],locked:false,pinned:false,collapsed:false,createdAt:Date.now()};
      state.categories[id]=cat;
    }
    cat.tags.push(...lines);
    saveState();
    render();
  };
  r.readAsText(f);
}

function exportAllTXT(){
  let o='';
  Object.values(state.categories).sort((a,b)=>a.name.localeCompare(b.name)).forEach(c=>{
    o+=`# ${c.name}\n`+c.tags.join('\n')+'\n\n';
  });
  download('tags.txt',o);
}

function exportJSON(){
  download('tags-backup.json', JSON.stringify(state,null,2));
}

function importJSON(e){
  const f=e.target.files[0];
  if(!f) return;
  const r=new FileReader();
  r.onload=()=>{
    const j=JSON.parse(r.result);
    state=normalizeState(j);
    selected=new Set(state.ui.selected||[]);
    saveState();
    applyTheme();
    render();
  };
  r.readAsText(f);
}

function exportCategoryTXT(catId){
  const cat=state.categories[catId];
  if(!cat) return;
  download(`${safeFile(cat.name)}.txt`, cat.tags.join('\n'));
}

function exportCategoryJSON(catId){
  const cat=state.categories[catId];
  if(!cat) return;
  const payload={version:2,categories:{[cat.id]:cat},groups:{},usage:state.usage.filter(u=>u.catId===cat.id),ui:{...state.ui,selected:[]}};
  download(`${safeFile(cat.name)}.json`, JSON.stringify(payload,null,2));
}

function exportGroupTXT(groupId){
  const g=state.groups[groupId];
  if(!g) return;
  let o=`# Group: ${g.name}\n\n`;
  g.categoryIds.forEach(id=>{
    const c=state.categories[id];
    if(!c) return;
    o+=`# ${c.name}\n`+c.tags.join('\n')+'\n\n';
  });
  download(`${safeFile(g.name)}.txt`, o);
}

function exportGroupJSON(groupId){
  const g=state.groups[groupId];
  if(!g) return;
  const cats={};
  g.categoryIds.forEach(id=>{ if(state.categories[id]) cats[id]=state.categories[id]; });
  const payload={version:2,categories:cats,groups:{[g.id]:g},usage:state.usage,ui:{...state.ui,selected:[]}};
  download(`${safeFile(g.name)}.json`, JSON.stringify(payload,null,2));
}

function download(name, text){
  const a=document.createElement('a');
  a.href=URL.createObjectURL(new Blob([text]));
  a.download=name;
  a.click();
}

function safeFile(name){
  return name.replace(/[^a-z0-9\- _]/gi,'_').slice(0,80);
}

// ---------- Panels / Settings ----------
function toggleRegexHelp(){regexHelp.classList.toggle('hidden');}
function toggleAIPanel(){
  aiPanel.classList.toggle('hidden');
  aiEnabledToggle.checked=state.ui.aiEnabled;
  autoCollapseToggle.checked=state.ui.autoCollapseOnSelect;
}
function setAIEnabled(v){state.ui.aiEnabled=!!v;saveState();}
function setAutoCollapse(v){state.ui.autoCollapseOnSelect=!!v;saveState();}

// ---------- AI (offline demo + online hook) ----------
function runOfflineGrouping(){
  const out=document.getElementById('aiResults');
  out.innerHTML='';
  const allTags=Object.values(state.categories).flatMap(c=>c.tags);
  if(allTags.length===0){out.innerHTML='<div class="small">No tags found to group.</div>';return;}

  const groups={};
  for(const t of allTags){
    const root=t.split(/[_-]/)[0].toLowerCase();
    if(!root) continue;
    (groups[root]=groups[root]||[]).push(t);
  }

  const keys=Object.keys(groups).filter(k=>groups[k].length>=2).sort((a,b)=>groups[b].length-groups[a].length);
  if(!keys.length){out.innerHTML='<div class="small">No strong offline groups found (need ‚â•2 tags sharing a root).</div>';return;}

  keys.slice(0,20).forEach(k=>{
    const div=document.createElement('div');
    div.className='panel';
    div.style.boxShadow='none';
    div.style.border='1px solid rgba(0,0,0,.08)';
    const sample=groups[k].slice(0,14);
    div.innerHTML=`
      <div class="row">
        <strong>Suggested category: ${escapeHtml(k)}</strong>
        <span class="spacer"></span>
        <button class="secondary" onclick="copyText('${escapeAttr(sample.join(', '))}')">Copy</button>
        <button onclick="createCategoryFromSuggestion('${escapeAttr(k)}')">Create Category</button>
      </div>
      <div class="small" style="margin-top:6px">${sample.map(escapeHtml).join(', ')}${groups[k].length>sample.length?' ‚Ä¶':''}</div>
    `;
    out.appendChild(div);
  });
}

function runOnlineGrouping(){
  if(!state.ui.aiEnabled){alert('Online AI is disabled for privacy. Enable it in the toggle first.');return;}
  alert('Online AI hook: here you would call an embeddings API, cluster results, then present suggestions with approve/reject + Undo.');
}

function copyText(t){
  const text=String(t);
  navigator.clipboard?.writeText(text).then(()=>showToast('Copied.', '')).catch(()=>alert(text));
}

function createCategoryFromSuggestion(name){
  const n=String(name||'').trim();
  if(!n) return;
  if(Object.values(state.categories).some(c=>c.name.toLowerCase()===n.toLowerCase())){alert('Category already exists');return;}
  const id=uid();
  state.categories[id]={id,name:n,color:newCategoryColor.value||'#4f46e5',tags:[],locked:false,pinned:false,collapsed:false,createdAt:Date.now()};
  saveState();
  render();
  showToast('Category created.', '');
}

function escapeHtml(str){
  return String(str)
    .replaceAll('&','&amp;')
    .replaceAll('<','&lt;')
    .replaceAll('>','&gt;')
    .replaceAll('"','&quot;')
    .replaceAll("'",'&#39;');
}
function escapeAttr(str){
  return escapeHtml(str).replaceAll('&#39;','\\\'');
}

// ---------- Rendering ----------
function render(){
  applyTheme();

  // parse regex safely
  const s=(search.value||'').toLowerCase();
  let rx=null;try{ if(regex.value) rx=new RegExp(regex.value,'i'); }catch{}

  // clear selection display
  globalOutput.value=[...selected].join(', ');

  const root=document.getElementById('content');
  root.innerHTML='';

  // top: groups controls
  const groupHeader=document.createElement('div');
  groupHeader.className='section-title';
  groupHeader.innerHTML=`<strong>Groups</strong><span class="small">Group categories for cleaner workflows.</span>`;
  root.appendChild(groupHeader);

  const groupControls=document.createElement('div');
  groupControls.className='controls';
  const createBtn=document.createElement('button');
  createBtn.textContent='Create Group';
  createBtn.onclick=createGroup;
  groupControls.appendChild(createBtn);
  root.appendChild(groupControls);

  const groups=Object.values(state.groups).sort((a,b)=>a.name.localeCompare(b.name));
  groups.forEach(g=>root.appendChild(renderGroup(g, s, rx)));

  // ungrouped categories
  const ungHeader=document.createElement('div');
  ungHeader.className='section-title';
  ungHeader.innerHTML=`<strong>Ungrouped Categories</strong><span class="small">Categories not assigned to a group.</span>`;
  root.appendChild(ungHeader);

  const groupedIds=new Set(groups.flatMap(g=>g.categoryIds||[]));

  const cats=Object.values(state.categories)
    .filter(c=>!groupedIds.has(c.id))
    .sort((a,b)=>(b.pinned?1:0)-(a.pinned?1:0) || a.name.localeCompare(b.name));

  cats.forEach(c=>root.appendChild(renderCategory(c, s, rx)));

  // delete mode UI
  updateDeleteUI();
}

function renderGroup(g, s, rx){
  const wrap=document.createElement('div');
  wrap.className='group'+(g.collapsed?' collapsed':'');
  wrap.style.borderLeft=`10px solid ${g.color||'#4f46e5'}`;

  const head=document.createElement('div');
  head.className='group-head';

  const left=document.createElement('div');
  left.className='group-left';

  const togg=document.createElement('span');
  togg.className='toggle';
  togg.textContent=g.collapsed?'‚ñ∂':'‚ñº';
  togg.title='Collapse/expand group';
  togg.onclick=()=>toggleGroupCollapse(g.id);

  const title=document.createElement('strong');
  title.textContent=g.name;

  left.append(togg,title);

  const right=document.createElement('div');
  right.className='row';

  const manage=document.createElement('button');
  manage.className='secondary';
  manage.textContent='Manage Categories';
  manage.onclick=()=>openGroupManager(g.id);

  const selAll=document.createElement('button');
  selAll.className='ghost';
  selAll.textContent='Select All Tags';
  selAll.onclick=()=>selectAllInGroup(g.id);

  const deselAll=document.createElement('button');
  deselAll.className='ghost';
  deselAll.textContent='Deselect All Tags';
  deselAll.onclick=()=>deselectAllInGroup(g.id);

  const expTxt=document.createElement('button');
  expTxt.className='secondary';
  expTxt.textContent='Export TXT';
  expTxt.onclick=()=>exportGroupTXT(g.id);

  const expJson=document.createElement('button');
  expJson.className='secondary';
  expJson.textContent='Export JSON';
  expJson.onclick=()=>exportGroupJSON(g.id);

  const rename=document.createElement('button');
  rename.className='ghost';
  rename.textContent='Rename';
  rename.onclick=()=>renameGroup(g.id);

  const recolor=document.createElement('button');
  recolor.className='ghost';
  recolor.textContent='Color';
  recolor.onclick=()=>recolorGroup(g.id);

  const del=document.createElement('button');
  del.className='danger';
  del.textContent='Delete Group';
  del.onclick=()=>deleteGroup(g.id);

  right.append(manage, selAll, deselAll, expTxt, expJson, rename, recolor, del);

  head.append(left,right);
  wrap.appendChild(head);

  const body=document.createElement('div');
  body.className='group-body';

  const cats=(g.categoryIds||[])
    .map(id=>state.categories[id])
    .filter(Boolean)
    .sort((a,b)=>(b.pinned?1:0)-(a.pinned?1:0) || a.name.localeCompare(b.name));

  if(!cats.length){
    const empty=document.createElement('div');
    empty.className='small';
    empty.textContent='No categories in this group yet. Use ‚ÄúManage Categories‚Äù to add some.';
    body.appendChild(empty);
  } else {
    cats.forEach(c=>body.appendChild(renderCategory(c, s, rx, g.color)));
  }

  wrap.appendChild(body);
  return wrap;
}

function renderCategory(c, s, rx, groupColor){
  const box=document.createElement('div');
  box.className='category'+(c.collapsed?' collapsed':'');
  box.style.borderLeft=`8px solid ${c.color||groupColor||'#4f46e5'}`;

  const h=document.createElement('div');
  h.className='category-header';

  const left=document.createElement('div');
  left.className='cat-left';

  const togg=document.createElement('span');
  togg.className='toggle';
  togg.textContent=c.collapsed?'‚ñ∂':'‚ñº';
  togg.title='Collapse/expand category';
  togg.onclick=()=>toggleCatCollapse(c.id);

  const title=document.createElement('strong');
  title.textContent=c.name;

  left.append(togg,title);

  const stats=document.createElement('span');
  stats.className='stat';
  const usedCount=state.usage.filter(u=>u.catId===c.id).length;
  stats.textContent=`${c.tags.length} tags | ${usedCount} used`;

  const pin=document.createElement('span');
  pin.className='pin';
  pin.textContent=c.pinned?'üìå':'üìç';
  pin.title='Pin/unpin';
  pin.onclick=()=>togglePin(c.id);

  const lockBtn=document.createElement('button');
  lockBtn.className='secondary';
  lockBtn.textContent=c.locked?'Unlock':'Lock';
  lockBtn.onclick=()=>toggleLock(c.id);

  const renameBtn=document.createElement('button');
  renameBtn.className='ghost';
  renameBtn.textContent='Rename';
  renameBtn.onclick=()=>renameCategory(c.id);

  const colorBtn=document.createElement('button');
  colorBtn.className='ghost';
  colorBtn.textContent='Color';
  colorBtn.onclick=()=>recolorCategory(c.id);

  const expTxt=document.createElement('button');
  expTxt.className='secondary';
  expTxt.textContent='Export TXT';
  expTxt.onclick=()=>exportCategoryTXT(c.id);

  const expJson=document.createElement('button');
  expJson.className='secondary';
  expJson.textContent='Export JSON';
  expJson.onclick=()=>exportCategoryJSON(c.id);

  const desel=document.createElement('button');
  desel.className='ghost';
  desel.textContent='Deselect Category';
  desel.onclick=()=>deselectCategory(c.id);

  const delBtn=document.createElement('button');
  delBtn.className='danger';
  delBtn.textContent='Delete Category';
  delBtn.onclick=()=>confirmDeleteCategory(c.id);

  h.append(left,stats,pin,lockBtn,renameBtn,colorBtn,expTxt,expJson,desel,delBtn);
  box.appendChild(h);

  const tags=document.createElement('div');
  tags.className='tags';
  if(c.locked) tags.classList.add('locked');

  const catSelected=[];

  c.tags.forEach((t,i)=>{
    if(s && !t.toLowerCase().includes(s)) return;
    if(rx && !rx.test(t)) return;

    const tag=document.createElement('div');
    tag.className='tag';
    tag.textContent=t;
    tag.draggable=!c.locked;

    const isSel=selected.has(t);
    if(isSel){tag.classList.add('selected');catSelected.push(t);} // best-effort per-cat output

    // mark state
    const markSet=deleteMarks.get(c.id);
    if(markSet && markSet.has(t)) tag.classList.add('mark');

    tag.onclick=()=>{
      if(deleteMode){
        let set=deleteMarks.get(c.id);
        if(!set){set=new Set();deleteMarks.set(c.id,set);}
        if(set.has(t)) set.delete(t); else set.add(t);
        updateMarkedCount();
        render();
        return;
      }

      if(selected.has(t)){
        selected.delete(t);
      } else {
        selected.add(t);
        // usage history
        state.usage.push({tag:t,catId:c.id,catName:c.name,time:new Date().toISOString()});
      }

      if(state.ui.autoCollapseOnSelect && !c.collapsed){
        c.collapsed=true;
      }

      saveState();
      render();
    };

    if(!c.locked){
      tag.ondragstart=e=>e.dataTransfer.setData('i',i);
      tag.ondragover=e=>e.preventDefault();
      tag.ondrop=e=>{
        const from=+e.dataTransfer.getData('i');
        const temp=c.tags[from];
        c.tags.splice(from,1);
        c.tags.splice(i,0,temp);
        saveState();
        render();
      };
    }

    tags.appendChild(tag);
  });

  box.appendChild(tags);

  const addWrap=document.createElement('div');
  addWrap.className='add-wrap';
  const add=document.createElement('input');
  add.placeholder='Add tag';
  add.disabled=c.locked;
  add.oninput=()=>suggest(add,c.id);
  add.onkeydown=e=>{ if(e.key==='Enter') addTag(c.id, add.value); };
  addWrap.appendChild(add);
  box.appendChild(addWrap);

  const out=document.createElement('textarea');
  out.className='cat-output';
  out.readOnly=true;
  out.placeholder='Selected in this category';
  out.value=catSelected.join(', ');
  box.appendChild(out);

  return box;
}

// initial UI
applyTheme();
render();

// Make sure toggles reflect state even if panel not opened yet
(function syncToggles(){
  // nothing: toggles are set on open
})();
</script>
</body>
</html>
